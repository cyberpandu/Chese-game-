<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simple Chess — HTML/CSS/JS</title>
  <style>
    :root{--light:#f0d9b5;--dark:#b58863;--accent:#3b82f6}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
    .app{display:flex;gap:24px;padding:24px;align-items:flex-start}
    .board{width:560px;height:560px;border-radius:12px;overflow:hidden;box-shadow:0 8px 24px rgba(2,6,23,0.15)}
    .row{display:flex;height:12.5%}
    .cell{flex:1;display:flex;align-items:center;justify-content:center;font-size:38px;cursor:pointer;user-select:none}
    .cell.light{background:var(--light)}
    .cell.dark{background:var(--dark)}
    .cell.highlight{outline:4px solid rgba(59,130,246,0.28);outline-offset:-4px}
    .hud{max-width:360px}
    .panel{background:#fff;padding:16px;border-radius:10px;box-shadow:0 6px 18px rgba(2,6,23,0.08);margin-bottom:14px}
    h1{margin:0 0 8px 0;font-size:18px}
    .controls{display:flex;gap:8px;margin-top:12px}
    button{padding:8px 10px;border-radius:8px;border:1px solid #e6e6e6;background:#fafafa;cursor:pointer}
    .status{font-weight:600;margin-top:6px}
    .coordinates{display:grid;grid-template-columns:repeat(2,1fr);gap:6px;margin-top:8px}
    .small{font-size:13px;color:#555}
    .move-list{max-height:300px;overflow:auto;padding-right:6px}
    .move-item{font-family:monospace;font-size:14px;padding:4px 0;border-bottom:1px dashed #eee}
    .turn-dot{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:8px;vertical-align:middle}
    .turn-white{background:#fff;border:2px solid #333}
    .turn-black{background:#000}
    footer.small{margin-top:12px;color:#666}
  </style>
</head>
<body>
  <div class="app">
    <div>
      <div class="board panel" id="board"></div>
    </div>
    <div class="hud">
      <div class="panel">
        <h1>Simple Chess</h1>
        <div class="small">Two-player local chess. Drag or click to move.</div>
        <div class="status" id="status">White to move</div>
        <div class="controls">
          <button id="resetBtn">Reset</button>
          <button id="undoBtn">Undo</button>
          <button id="flipBtn">Flip Board</button>
        </div>
        <div class="coordinates">
          <div class="small">Selected: <span id="selected">—</span></div>
          <div class="small">Last move: <span id="lastMove">—</span></div>
        </div>
      </div>
      <div class="panel">
        <strong>Moves</strong>
        <div class="move-list" id="moveList"></div>
      </div>
      <div class="panel small">
        Notes: This demo enforces legal moves (including check) and pawn promotion. Castling and en-passant are not implemented in this simplified version but can be added.
      </div>
    </div>
  </div>

<script>
// --- Simple Chess Implementation ---
// Board representation: 8x8 array, each square either null or {type:'p','r','n','b','q','k', color:'w'|'b'}
// Coordinates: board[r][c], r=0 top (black's 8th rank) to 7 bottom (white's 1st rank)

const pieceUnicode = {
  'wp':'\u2659','wn':'\u2658','wb':'\u2657','wr':'\u2656','wq':'\u2655','wk':'\u2654',
  'bp':'\u265F','bn':'\u265E','bb':'\u265D','br':'\u265C','bq':'\u265B','bk':'\u265A'
}

let boardState = null;
let selected = null;
let legalHighlights = [];
let whiteToMove = true;
let history = [];
let flipped = false;

const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');
const selectedEl = document.getElementById('selected');
const lastMoveEl = document.getElementById('lastMove');
const moveListEl = document.getElementById('moveList');

function initBoard(){
  boardState = Array.from({length:8},_=>Array(8).fill(null));
  const back = ['r','n','b','q','k','b','n','r'];
  for(let i=0;i<8;i++) boardState[0][i] = {type:back[i],color:'b'};
  for(let i=0;i<8;i++) boardState[1][i] = {type:'p',color:'b'};
  for(let i=0;i<8;i++) boardState[6][i] = {type:'p',color:'w'};
  for(let i=0;i<8;i++) boardState[7][i] = {type:back[i],color:'w'};
  selected = null; legalHighlights = []; history = []; whiteToMove = true; flipped=false;
}

function render(){
  boardEl.innerHTML = '';
  let rows = [...Array(8).keys()];
  if(flipped) rows = rows.reverse();
  for(let rIndex=0;rIndex<8;rIndex++){
    const r = rows[rIndex];
    const rowEl = document.createElement('div'); rowEl.className='row';
    let cols = [...Array(8).keys()]; if(flipped) cols = cols.reverse();
    for(let cIndex=0;cIndex<8;cIndex++){
      const c = cols[cIndex];
      const cell = document.createElement('div');
      const light = (r+c)%2===0;
      cell.className = 'cell '+(light? 'light':'dark');
      cell.dataset.r = r; cell.dataset.c = c;
      const piece = boardState[r][c];
      if(piece){
        const key = piece.color+piece.type;
        cell.textContent = pieceUnicode[key] || '?';
        cell.title = piece.color==='w' ? 'White '+piece.type.toUpperCase() : 'Black '+piece.type.toUpperCase();
      }
      // highlight if in legalHighlights
      if(selected && selected.r==r && selected.c==c) cell.classList.add('highlight');
      for(const h of legalHighlights){ if(h.r==r && h.c==c) cell.classList.add('highlight'); }

      cell.addEventListener('click',onCellClick);
      rowEl.appendChild(cell);
    }
    boardEl.appendChild(rowEl);
  }
  statusEl.textContent = (whiteToMove? 'White':'Black') + ' to move' + (isInCheck(whiteToMove?'w':'b')? ' — CHECK':'');
  selectedEl.textContent = selected ? coordToAlgebraic(selected.r,selected.c) : '—';
  renderMoveList();
}

function onCellClick(e){
  const r = +this.dataset.r; const c = +this.dataset.c;
  const sq = boardState[r][c];
  const turnColor = whiteToMove? 'w':'b';
  if(selected){
    // if clicked a legal move
    if(legalHighlights.some(h=>h.r==r&&h.c==c)){
      makeMove(selected,{r,c});
      selected=null; legalHighlights=[]; render(); return;
    }
  }
  // otherwise select if piece of current color
  if(sq && sq.color===turnColor){ selected={r,c}; legalHighlights = getLegalMoves(r,c); } else { selected=null; legalHighlights=[]; }
  render();
}

function makeMove(from,to){
  const piece = boardState[from.r][from.c];
  const target = boardState[to.r][to.c];
  // save history
  history.push({from,to,piece:JSON.parse(JSON.stringify(piece)),captured: target? JSON.parse(JSON.stringify(target)):null, whiteToMove});
  // move
  boardState[to.r][to.c] = piece;
  boardState[from.r][from.c] = null;
  // pawn promotion
  if(piece.type==='p' && (to.r===0 || to.r===7)){
    const prom = prompt('Promote pawn to (q,r,b,n). Default: q','q') || 'q';
    piece.type = ['q','r','b','n'].includes(prom.toLowerCase())? prom.toLowerCase() : 'q';
  }
  whiteToMove = !whiteToMove;
  lastMoveEl.textContent = coordToAlgebraic(from.r,from.c) + ' → ' + coordToAlgebraic(to.r,to.c);
  // check for checkmate or stalemate
  if(isCheckmate(whiteToMove? 'w':'b')){
    alert((whiteToMove? 'White':'Black') + ' is checkmated. ' + (whiteToMove? 'Black':'White') + ' wins!');
  } else if(isStalemate(whiteToMove? 'w':'b')){
    alert('Stalemate — draw');
  }
}

function undo(){
  const last = history.pop(); if(!last) return;
  const {from,to,piece,captured,whiteToMove:prevTurn} = last;
  boardState[from.r][from.c] = piece;
  boardState[to.r][to.c] = captured;
  whiteToMove = prevTurn;
  selected=null; legalHighlights=[]; render();
}

function renderMoveList(){
  moveListEl.innerHTML='';
  for(let i=0;i<history.length;i++){
    const h = history[i];
    const div = document.createElement('div'); div.className='move-item';
    div.textContent = (i+1)+'. ' + coordToAlgebraic(h.from.r,h.from.c) + '→' + coordToAlgebraic(h.to.r,h.to.c) + (h.captured? ' x':'');
    moveListEl.appendChild(div);
  }
}

// --- Utilities: algebraic coords ---
function coordToAlgebraic(r,c){ const file = String.fromCharCode('a'.charCodeAt(0)+c); const rank = 8-r; return file+rank; }
function algebraicToCoord(s){ const c = s.charCodeAt(0)-'a'.charCodeAt(0); const r = 8-Number(s[1]); return {r,c}; }

// --- Move generation (simplified but enforces check) ---
function getLegalMoves(r,c){
  const piece = boardState[r][c]; if(!piece) return [];
  const pseudo = getPseudoLegal(r,c);
  // filter out moves that leave own king in check
  const legal = [];
  for(const mv of pseudo){
    const snapshot = JSON.parse(JSON.stringify(boardState));
    const fromPiece = snapshot[r][c];
    snapshot[mv.r][mv.c] = fromPiece;
    snapshot[r][c] = null;
    // promotion not considered here for checking
    if(!isKingInCheckForBoard(snapshot,piece.color)) legal.push(mv);
  }
  return legal;
}

function getPseudoLegal(r,c){
  const p = boardState[r][c]; if(!p) return [];
  const moves = [];
  const dirs = {rook:[[1,0],[-1,0],[0,1],[0,-1]],bishop:[[1,1],[1,-1],[-1,1],[-1,-1]],queen:[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]};
  if(p.type==='p'){
    const dir = p.color==='w' ? -1 : 1;
    const startRow = p.color==='w'?6:1;
    // one forward
    if(inBounds(r+dir,c) && !boardState[r+dir][c]) moves.push({r:r+dir,c});
    // two forward
    if(r===startRow && !boardState[r+dir][c] && !boardState[r+2*dir][c]) moves.push({r:r+2*dir,c});
    // captures
    for(const dc of [-1,1]){
      const rr=r+dir, cc=c+dc; if(inBounds(rr,cc) && boardState[rr][cc] && boardState[rr][cc].color!==p.color) moves.push({r:rr,c:cc});
    }
    return moves;
  }
  if(p.type==='n'){
    const steps=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
    for(const s of steps){const rr=r+s[0],cc=c+s[1]; if(inBounds(rr,cc) && (!boardState[rr][cc]||boardState[rr][cc].color!==p.color)) moves.push({r:rr,c:cc});}
    return moves;
  }
  if(p.type==='b' || p.type==='r' || p.type==='q'){
    const list = p.type==='b'?dirs.bishop: p.type==='r'?dirs.rook:dirs.queen;
    for(const d of list){
      let rr=r+d[0], cc=c+d[1];
      while(inBounds(rr,cc)){
        if(!boardState[rr][cc]){ moves.push({r:rr,c:cc}); }
        else { if(boardState[rr][cc].color!==p.color) moves.push({r:rr,c:cc}); break; }
        rr+=d[0]; cc+=d[1];
      }
    }
    return moves;
  }
  if(p.type==='k'){
    for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++){ if(dr===0&&dc===0) continue; const rr=r+dr,cc=c+dc; if(inBounds(rr,cc)&&(!boardState[rr][cc]||boardState[rr][cc].color!==p.color)) moves.push({r:rr,c:cc}); }
    // castling omitted in this demo
    return moves;
  }
  return moves;
}

function inBounds(r,c){ return r>=0 && r<8 && c>=0 && c<8; }

// --- Check/checkmate/stalemate detection ---
function findKing(board,color){ for(let r=0;r<8;r++)for(let c=0;c<8;c++){ const p=board[r][c]; if(p && p.type==='k' && p.color===color) return {r,c}; } return null; }

function isKingInCheckForBoard(board,color){ const king = findKing(board,color); if(!king) return true; // no king = treated as in check
  // check attacks by opponent pieces
  const opp = color==='w'? 'b':'w';
  // pawn attacks
  const dir = opp==='w' ? -1:1; // pawns of opp
  for(const dc of [-1,1]){
    const rr=king.r+dir, cc=king.c+dc; if(inBounds(rr,cc) && board[rr][cc] && board[rr][cc].type==='p' && board[rr][cc].color===opp) return true;
  }
  // knights
  const ksteps=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
  for(const s of ksteps){const rr=king.r+s[0],cc=king.c+s[1]; if(inBounds(rr,cc) && board[rr][cc] && board[rr][cc].type==='n' && board[rr][cc].color===opp) return true;}
  // sliders (rook/bishop/queen)
  const dirs=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
  for(const d of dirs){ let rr=king.r+d[0], cc=king.c+d[1]; let steps=1; while(inBounds(rr,cc)){ const p=board[rr][cc]; if(p){ if(p.color===opp){ if( (Math.abs(d[0])===1&&Math.abs(d[1])===1 && (p.type==='b'||p.type==='q')) || ((d[0]===0||d[1]===0) && (p.type==='r'||p.type==='q')) ) return true; // adjacent king?
        if(steps===1 && p.color===opp && p.type==='k') return true; }
        break; }
      rr+=d[0]; cc+=d[1]; steps++; }
  }
  return false;
}

function isInCheck(color){ return isKingInCheckForBoard(boardState,color); }

function isAnyLegalMoveExists(color){
  for(let r=0;r<8;r++)for(let c=0;c<8;c++){ const p=boardState[r][c]; if(p && p.color===color){ const moves = getLegalMoves(r,c); if(moves.length>0) return true; } }
  return false;
}

function isCheckmate(color){ return isInCheck(color) && !isAnyLegalMoveExists(color); }
function isStalemate(color){ return !isInCheck(color) && !isAnyLegalMoveExists(color); }

// --- UI controls ---
document.getElementById('resetBtn').addEventListener('click',()=>{ initBoard(); render(); });
document.getElementById('undoBtn').addEventListener('click',()=>{ undo(); });
document.getElementById('flipBtn').addEventListener('click',()=>{ flipped = !flipped; render(); });

initBoard(); render();

// Optional: support keyboard selection / arrow keys or drag and drop could be added later

</script>
</body>
</html>